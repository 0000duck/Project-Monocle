using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Runtime.CompilerServices;

public static class ExtensionMethods
{
    public static void ForEach<T>(this IEnumerable<T> enumerable, Action<T> action)
    {
        foreach (var item in enumerable)
        {
            action(item);
        }
    }

    public static IEnumerable<FieldInfo> GetAllFields(this Type type)
    {
        while (true)
        {
            if (type == null)
                break;

            var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly;
            foreach (var field in type.GetFields(flags))
                yield return field;

            type = type.BaseType;
        }
    }

    public static bool HasDefaultConstructor(this Type type)
    {
        if (type.IsValueType)
            return true;

        return type.IsClass &&
               type.GetConstructors().Length == 0 ||
               type.GetConstructor(BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null) != null;
    }

    public static bool IsAutoGenerated(this PropertyInfo info)
    {
        bool isCompilerGenerated = info.GetGetMethod().IsDefined(typeof(CompilerGeneratedAttribute), true);
        if (!isCompilerGenerated)
            return false;

        return info.DeclaringType.GetFields(BindingFlags.NonPublic | BindingFlags.Instance)
                                 .Where(f => f.Name.Contains(info.Name) && f.Name.Contains("BackingField"))
                                 .Where(f => f.IsDefined(typeof(CompilerGeneratedAttribute), true)).Any();
    }
}